به نام خدا
# تمرین شماره ۱ – مروری بر اصول شی‌گرایی (SOLID)

این مخزن شامل پیاده‌سازی گام‌های ۱ تا ۵ تمرین «مروری بر اصول شی‌گرایی» است. برنامه‌ی اولیه یک نمونه ساده از سیستم رزرو هتل بود که در طول این تمرین توسعه داده شد تا اثر رعایت اصول SOLID در طراحی نرم‌افزار بررسی شود.

---

## مقدمه

هدف از این تمرین آن است که دانشجو به صورت عملی با اصول SOLID آشنا شود و تأثیر رعایت یا عدم رعایت این اصول را در توسعه، نگهداری و افزودن قابلیت‌های جدید در یک پروژه واقعی مشاهده کند.

---

# گام اول – افزودن قابلیت‌ها در نسخه بدون SOLID  
(پوشه: **OOD-without-01-Step**)

در این مرحله، دو قابلیت جدید به نسخه اصلی برنامه افزوده شد:

### 1. افزودن قابلیت ارسال پیامک (SMS)
- اضافه شدن متد `sendSms` به اینترفیس پیام‌رسان  
- ایجاد کلاس جدید `SmsSender`  
- افزودن منطق انتخاب پیام‌رسان در ReservationService  
- اصلاح کلاس Main برای استفاده از پیامک

### 2. افزودن روش پرداخت حضوری (On-Site Payment)
- افزودن متد `payOnSite` به کلاس PaymentProcessor  
- اضافه شدن case جدید برای روش پرداخت  
- اصلاح کلاس Main برای استفاده از پرداخت حضوری

---

## جدول تغییرات گام اول

<table border="1" cellspacing="0" cellpadding="6">
<tr>
<th>ردیف</th>
<th>کلاس تغییر یافته (پیامک)</th>
<th>توضیح تغییر</th>
<th>کلاس تغییر یافته (پرداخت)</th>
<th>توضیح تغییر</th>
</tr>

<tr>
<td>1</td>
<td>MessageSender</td>
<td>افزودن متد جدید <code>sendSms</code></td>
<td>PaymentProcessor</td>
<td>افزودن متد جدید <code>payOnSite</code></td>
</tr>

<tr>
<td>2</td>
<td>EmailSender</td>
<td>پیاده‌سازی خالی متد <code>sendSms</code></td>
<td>ReservationService</td>
<td>افزودن case پرداخت حضوری</td>
</tr>

<tr>
<td>3</td>
<td>SmsSender</td>
<td>ایجاد کلاس جدید برای ارسال پیامک</td>
<td>—</td>
<td>—</td>
</tr>

<tr>
<td>4</td>
<td>ReservationService</td>
<td>افزودن منطق انتخاب ایمیل/پیامک</td>
<td>—</td>
<td>—</td>
</tr>

<tr>
<td>5</td>
<td>Main</td>
<td>اصلاح Main برای استفاده از SmsSender</td>
<td>Main</td>
<td>افزودن انتخاب روش پرداخت</td>
</tr>
</table>

**تعداد کل تغییرات: ۱۰**

---

# گام دوم – تحلیل اصول SOLID در نسخه اولیه

## جدول تحلیل اصول SOLID 

<table border="1" cellspacing="0" cellpadding="6">
<tr>
<th>اصل</th>
<th>وضعیت</th>
<th>توضیح</th>
</tr>

<tr>
<td>SRP</td>
<td>نقض</td>
<td>کلاس ReservationService چندین وظیفه دارد (رزرو، ارسال پیام، مدیریت پرداخت).</td>
</tr>

<tr>
<td>SRP</td>
<td>برقرار</td>
<td>کلاس‌های Room و Customer فقط مسئول نگهداری داده‌های خود هستند.</td>
</tr>

<tr>
<td>OCP</td>
<td>نقض</td>
<td>افزودن پیام‌رسان یا روش پرداخت جدید نیازمند تغییر مستقیم در کد است.</td>
</tr>

<tr>
<td>OCP</td>
<td>برقرار</td>
<td>Room و LuxuryRoom گسترش را بدون تغییر کد والد انجام می‌دهند.</td>
</tr>

<tr>
<td>LSP</td>
<td>برقرار</td>
<td>LuxuryRoom می‌تواند جایگزین Room شود.</td>
</tr>

<tr>
<td>ISP</td>
<td>نقض</td>
<td>اینترفیس MessageSender متدهای نامرتبط دارد و کلاس‌ها را مجبور به پیاده‌سازی خالی می‌کند.</td>
</tr>

<tr>
<td>DIP</td>
<td>نقض</td>
<td>Main مستقیماً به کلاس‌های سطح پایین مانند EmailSender وابسته است.</td>
</tr>

<tr>
<td>LoD</td>
<td>نقض</td>
<td>در ReservationService دسترسی زنجیره‌ای به فیلدهای داخلی آبجکت‌ها وجود دارد.</td>
</tr>

</table>

---

# گام سوم – اصلاح ساختار با رعایت SOLID  
(پوشه: **OOD-with-02-Step**)

در این مرحله نسخه اصلاح‌شده با رعایت اصول SOLID پیاده‌سازی شد.

### اقدامات مهم:

### ✔ تفکیک اینترفیس‌ها (رفع ISP)
- تقسیم MessageSender به EmailService و SmsService

### ✔ استفاده از الگوی استراتژی برای پرداخت‌ها (رفع OCP / SRP)
- ایجاد اینترفیس PaymentMethod  
- ساخت کلاس‌های مستقل:  
  CardPayment ،CashPayment ،PaypalPayment ،OnSitePayment

### ✔ تزریق وابستگی (رفع DIP)
- ReservationService دیگر آبجکت‌ها را ایجاد نمی‌کند  
- وابستگی‌ها از بیرون تزریق می‌شوند

### ✔ کاهش وابستگی داخلی (رفع LoD)
- دسترسی مستقیم به فیلدهای تو در تو حذف شد  
- مسئولیت محاسبه هزینه به Reservation منتقل شد

---

# گام چهارم – مقایسه تعداد تغییرات قبل و بعد از SOLID

## جدول مقایسه 

<table border="1" cellspacing="0" cellpadding="6">
<tr>
<th>قابلیت</th>
<th>تغییرات در نسخه اولیه</th>
<th>تغییرات در نسخه اصلاح شده</th>
<th>تعداد تغییرات حذف شده</th>
</tr>

<tr>
<td>افزودن پیامک (SMS)</td>
<td>۴ کلاس</td>
<td>۲ کلاس</td>
<td>۲ کلاس</td>
</tr>

<tr>
<td>پرداخت حضوری</td>
<td>۲ کلاس</td>
<td>۱ کلاس</td>
<td>۱ کلاس</td>
</tr>

</table>

**نتیجه:**  
۳ تغییر غیرضروری در نسخه SOLID حذف شد و افزودن قابلیت‌های جدید ساده‌تر شد.

---

# گام پنجم – نتیجه‌گیری

رعایت اصول SOLID باعث شد:

- افزودن قابلیت‌های جدید بدون تغییر در کلاس‌های موجود انجام شود  
- وابستگی‌ها کاهش پیدا کند  
- ساختار کد واضح‌تر و قابل نگهداری‌تر شود  
- خطر ایجاد خطا هنگام توسعه کم شود  
- تست‌پذیری و خوانایی به شکل قابل توجهی افزایش پیدا کند

نتیجه نهایی این است که رعایت اصول شی‌گرایی، توسعه نرم‌افزار را پایدارتر و قابل‌گسترش‌تر می‌کند.

---

پایان
